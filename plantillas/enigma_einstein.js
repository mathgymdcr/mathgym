export async function render(root, data, hooks){
  root.innerHTML = `<div class="template-box" id="ein">
<div class="badge">Enigma de Einstein</div>
<div id="ein-status" class="feedback"></div>
<div class="ein-grid">
<section class="ein-clues"><h4>Pistas</h4><ol id="ein-clues"></ol><button class="btn" id="ein-validate">Validar solución</button><div id="ein-result" class="feedback" aria-live="polite"></div></section>
<section class="ein-palette"><h4>Tarjetas</h4><div id="ein-palette"></div></section>
<section class="ein-board"><h4>Tablero</h4><div id="ein-board"></div></section>
</div></div>`;
  const box=root.querySelector('#ein'); const status=box.querySelector('#ein-status');
  let cfg=null; try{ cfg=await loadConfig(data); }catch(err){ status.textContent='Error cargando JSON: '+(err?.message||err); status.className='feedback ko'; return; }
  const solv=solveEinstein(cfg,2); if(solv.count===0){ status.textContent='Enigma NO resoluble'; status.className='feedback ko'; } else if(solv.count===1){ status.textContent='Solución única'; status.className='feedback ok'; } else { status.textContent='Múltiples soluciones'; }
  const state={selected:null, board:Array(cfg.houses).fill(0).map(()=>({}))};
  renderClues(box.querySelector('#ein-clues'), cfg);
  renderPalette(box.querySelector('#ein-palette'), cfg, (sel)=>{ state.selected=sel; updateSelectionUI(box, sel); });
  renderBoard(box.querySelector('#ein-board'), cfg, state, ()=>{ state.selected=null; updateSelectionUI(box, null); });
  box.querySelector('#ein-validate').addEventListener('click',()=>{ const r=validateUserBoard(cfg,state.board); const el=box.querySelector('#ein-result'); el.textContent=r.ok?'Compatible':'Incompatible'; el.className='feedback '+(r.ok?'ok':'ko'); if(r.ok) hooks?.onSuccess?.(); });
}
async function loadConfig(data){ if(data?.json_url){ const r=await fetch(data.json_url,{cache:'no-cache'}); if(!r.ok) throw new Error('HTTP '+r.status); return await r.json(); } if(data?.categories||data?.constraints) return data; throw new Error('Falta data.json_url'); }
function renderClues(ol,cfg){ ol.innerHTML=(cfg.clues||[]).map(c=>`<li>${escapeHtml(c)}</li>`).join(''); }
function renderPalette(container,cfg,onSelect){ container.innerHTML=''; for(const [cat,vals] of Object.entries(cfg.categories)){ const g=document.createElement('div'); g.className='ein-group'; g.innerHTML=`<h5>${escapeHtml(cat)}</h5><div class="ein-cards"></div>`; const wrap=g.querySelector('.ein-cards'); vals.forEach(v=>{const b=document.createElement('button'); b.type='button'; b.className='btn ein-card'; b.textContent=v; b.dataset.cat=cat; b.dataset.val=v; b.addEventListener('click',()=>onSelect({cat,value:v})); wrap.appendChild(b);}); container.appendChild(g);} }
function renderBoard(container,cfg,state,cancel){ container.innerHTML=''; const grid=document.createElement('div'); grid.className='ein-board-grid'; const cats=Object.keys(cfg.categories); const head=document.createElement('div'); head.className='ein-row ein-head'; head.innerHTML='<div></div>'+Array(cfg.houses).fill(0).map((_,i)=>`<div class="ein-cell-head">Casa ${i+1}</div>`).join(''); grid.appendChild(head); cats.forEach(cat=>{ const row=document.createElement('div'); row.className='ein-row'; const col=document.createElement('div'); col.className='ein-cat'; col.textContent=cat; row.appendChild(col); for(let i=0;i<cfg.houses;i++){ const cell=document.createElement('div'); cell.className='ein-cell'; cell.dataset.house=String(i); cell.dataset.cat=cat; cell.addEventListener('click',(e)=>{ e.stopPropagation(); const chip=cell.querySelector('.ein-chip'); if(chip){ cell.innerHTML=''; delete state.board[i][cat]; cancel(); return; } if(!state.selected){ cancel(); return; } const sel=state.selected; state.board[i][cat]=sel.value; cell.innerHTML=`<button type="button" class="ein-chip" title="${sel.value}">${sel.value}</button>`; cancel(); }); row.appendChild(cell); } grid.appendChild(row); }); container.appendChild(grid); container.addEventListener('click',()=>cancel()); }
function updateSelectionUI(box,sel){ box.querySelectorAll('.ein-card').forEach(b=>b.classList.remove('is-selected')); if(sel){ const q=`.ein-card[data-cat="${cssEsc(sel.cat)}"][data-val="${cssEsc(sel.value)}"]`; const btn=box.querySelector(q); if(btn) btn.classList.add('is-selected'); } }
function cssEsc(s){ return String(s).replace(/"/g,'\"'); }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;",""":"&quot;","'":"&#39;"}[m])); }
function solveEinstein(cfg,cap=2){ const N=cfg.houses; const cats=Object.keys(cfg.categories); const D=new Map(); for(const cat of cats){ for(const v of cfg.categories[cat]) D.set(cat+':'+v, new Set([...Array(N).keys()])); } const C=cfg.constraints||[]; function setTo(dom,other){ let ch=false; for(const x of [...dom]) if(!other.has(x)){ dom.delete(x); ch=true; } return ch; } function inter(A,B){ const I=new Set(); for(const x of A){ if(B.has(x)) I.add(x);} return I; } function apply(){ let ch=false; C.forEach(c=>{ if(c.type==='position'){ const k=c.a.cat+':'+c.a.val; ch|=setTo(D.get(k), new Set([c.pos])); } if(c.type==='not_position'){ const k=c.a.cat+':'+c.a.val; const d=D.get(k); if(d.has(c.pos)){ d.delete(c.pos); ch=true; } } }); for(const cat of cats){ const vs=cfg.categories[cat]; const fixed=[]; vs.forEach(v=>{ const d=D.get(cat+':'+v); if(d.size===1) fixed.push([...d][0]); }); vs.forEach(v=>{ const d=D.get(cat+':'+v); fixed.forEach(p=>{ if(d.size>1 && d.has(p)){ d.delete(p); ch=true; } }); }); } C.forEach(c=>{ const get=(x)=>D.get(x.cat+':'+x.val); if(c.type==='eq'){ const A=get(c.a),B=get(c.b); const I=inter(A,B); ch|=setTo(A,I)|setTo(B,I); } else if(c.type==='neq'){ const A=get(c.a),B=get(c.b); const I=inter(A,B); if(I.size){ I.forEach(p=>{ if(A.size>1&&A.has(p)){A.delete(p); ch=true;} if(B.size>1&&B.has(p)){B.delete(p); ch=true;} }); } } else if(c.type==='left_of'){ const A=get(c.a),B=get(c.b); const Ad=new Set(),Bd=new Set(); for(const i of A){ for(const j of B){ if(i<j){Ad.add(i); Bd.add(j);} } } ch|=setTo(A,Ad)|setTo(B,Bd); } else if(c.type==='next_to'){ const A=get(c.a),B=get(c.b); const Ad=new Set(),Bd=new Set(); for(const i of A){ for(const j of B){ if(Math.abs(i-j)===1){Ad.add(i); Bd.add(j);} } } ch|=setTo(A,Ad)|setTo(B,Bd); } }); return ch; }
 function propagate(){ let loop=true; while(loop){ loop=false; if(apply()) loop=true; for(const [k,d] of D){ if(d.size===0) return false; } } return true; } function choose(){ let best=null,sz=1e9; for(const [k,d] of D){ if(d.size>1 && d.size<sz){ sz=d.size; best=k; } } return best; } function assign(k,v){ const d=D.get(k); const b=new Set(d); D.set(k,new Set([v])); return b; } function restore(k,b){ D.set(k,b); } function dfs(cnt){ if(cnt>=cap) return cnt; if(!propagate()) return cnt; const k=choose(); if(!k) return cnt+1; const dom=[...D.get(k)]; for(const v of dom){ const bak=assign(k,v); cnt=dfs(cnt); restore(k,bak); if(cnt>=cap) break; } return cnt; } return {count: dfs(0)}; }
function validateUserBoard(cfg,board){ const N=cfg.houses; const cats=Object.keys(cfg.categories); const find=(cat,val)=>{ for(let i=0;i<N;i++){ if(board[i][cat]===val) return i; } return -1; }; const C=cfg.constraints||[]; for(const c of C){ if(c.type==='position'){ const i=find(c.a.cat,c.a.val); if(i!==-1 && i!==c.pos) return {ok:false}; } else if(c.type==='not_position'){ const i=find(c.a.cat,c.a.val); if(i===c.pos) return {ok:false}; } else if(c.type==='eq'){ const i=find(c.a.cat,c.a.val), j=find(c.b.cat,c.b.val); if(i!==-1 && j!==-1 && i!==j) return {ok:false}; } else if(c.type==='neq'){ const i=find(c.a.cat,c.a.val), j=find(c.b.cat,c.b.val); if(i!==-1 && j!==-1 && i===j) return {ok:false}; } else if(c.type==='left_of'){ const i=find(c.a.cat,c.a.val), j=find(c.b.cat,c.b.val); if(i!==-1 && j!==-1 && !(i<j)) return {ok:false}; } else if(c.type==='next_to'){ const i=find(c.a.cat,c.a.val), j=find(c.b.cat,c.b.val); if(i!==-1 && j!==-1 && Math.abs(i-j)!==1) return {ok:false}; } } return {ok:true}; }
export const __test__ = { solveEinstein, validateUserBoard };
